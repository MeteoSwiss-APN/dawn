/*===------------------------------------------------------------------------------*- proto -*-===*\
 *                          _
 *                         | |
 *                       __| | __ ___      ___ ___
 *                      / _` |/ _` \ \ /\ / / '_  |
 *                     | (_| | (_| |\ V  V /| | | |
 *                      \__,_|\__,_| \_/\_/ |_| |_| - Compiler Toolchain
 *
 *
 *  This file is distributed under the MIT License (MIT).
 *  See LICENSE.txt for details.
 *
\*===------------------------------------------------------------------------------------------===*/

// @defgroup sir_proto SIR protobuf
// @brief This is a SIR description for Google's protocol buffers library 
// <a href="https://developers.google.com/protocol-buffers/">Protobuf</a>.

syntax = "proto3";

package dawn.sir.proto;

// @brief Source information
//
// `(-1,-1)` indicates an invalid location.
// @ingroup sir_proto
message SourceLocation {
  int32 Line = 1;   // Source line 
  int32 Column = 2; // Column in the `Line`
}

// @brief Stencil attributes
//
// Stencil attributes can be used to adjust optimization and code generation for individual stencil
// and stencil_functions.
// @ingroup sir_proto
message Attributes {
  bool no_codegen = 1;        // Don't generate code for this stencil
  bool merge_stages = 2;      // Merge the Stages of this stencil
  bool merge_do_methods = 3;  // Merge the Do-Methods of this stencil
  bool merge_temporaries = 4; // Merge the temporaries of this stencil
  bool use_k_caches = 5;      // Use K-Caches
}

// @brief Description of a field argument of a Stencil or StencilFunction
// @ingroup sir_proto
message Field {
  string name = 1;        // Name of the field
  SourceLocation loc = 2; // Source location
  bool is_temporary = 3;  // Is the field a temporary?
}

// @brief Directional argument of a StencilFunction
//
// Note that this message is merely a placeholder as the actual arguments is encoded as an AST node.
// @ingroup sir_proto
message Direction {
  string name = 1;        // Name of the directional argument
  SourceLocation loc = 2; // Source location
}

// @brief Offset argument of a StencilFunction
//
// Note that this message is merely a placeholder as the actual arguments is encoded as an AST node.
// @ingroup sir_proto
message Offset {
  string name = 1;        // Name of the offset argument
  SourceLocation loc = 2; // Source location
}

// @brief Directional argument of a StencilFunction
// @ingroup sir_proto
message StencilFunctionArg {
  // One of Field, Direction or Offset
  oneof Arg {
    Field field_value = 1;
    Direction direction_value = 2;
    Offset offset_value = 3;
  }
}

// @brief Representation of a vertical interval, given by a lower and upper bound where a bound
// is represented by a level and an offset (`bound = level + offset`)
//
// The Interval has to satisfy the following invariants:
//  - `lowerLevel >= Interval::Start`
//  - `upperLevel <= Interval::End`
//  - `(lowerLevel + lowerOffset) <= (upperLevel + upperOffset)`
//
// @ingroup sir_proto
message Interval {
  // @brief Description of a level
  //
  // A level can be any integer between `[Start, End]` while the `Start` and `End` levels are
  // treated specially. Note that if `special_level_value` is `SpecialLevel::Start` or
  // `SpecialLevel::End`, the value of `level_value` is ignored.
  message Level {
    enum SpecialLevel {
      Noting = 0; // No special level, use the numerica value of `level_value` instead
      Start = 1;  // The first level
      End = 2;    // The last level
    }

    int32 level_value = 1;                // Numeric value of the level
    SpecialLevel special_level_value = 2; // Encoding of special levels (`Start` and `End`)
  }

  Level lower_level = 1;  // Lover level
  Level upper_level = 2;  // Upper level
  int32 lower_offset = 3; // Lower offset added to `lower_level`
  int32 upper_offset = 4; // Upper offset added to `upper_level`
}

/*===------------------------------------------------------------------------------------------===*\
 *     AST
\*===------------------------------------------------------------------------------------------===*/

// @brief Identifier of a specific statement
//
// Statements IDs directly related to a statement in the `AST.statements` map.
// @ingroup sir_proto
message StmtID {
  int32 id = 1;  // Key into the `AST.statements` map
}

// @brief A block of `N` statetements
//
// Synopsis
// @code{.cpp}
// {
//  statement_1
//  statement_2
//  ...
//  statement_N
// }
// @endcode
// @ingroup sir_proto
 message BlockStmt {
   repeated StmtID statements = 1;  // List of statements
 }

// @brief This message holds the actual value of a statement
// @ingroup sir_proto
message Stmt {
  oneof stmt { BlockStmt block_stmt_value = 1; }
}

// @brief Identifier of a specific expression
//
// Expression IDs directly related to an expression in the `AST.expressions` map.
// @ingroup sir_proto
message ExprID {
  int32 id = 1; // Key into the `AST.expressions` map
}

// @brief Apply the unary operations to an expression
//
// Synopsis
// @code{.cpp}
//  op operand
// @endcode
// @ingroup sir_proto
message UnaryOperator {
  string op = 1;      // Operation (e.g "+" or "-")
  ExprID operand = 2; // Expression to apply the operation
}

// @brief This message holds the actual value of an expression
// @ingroup sir_proto
message Expr {
  oneof expr { UnaryOperator unary_operator_value = 1; }
}

// @brief Abstract syntax tree of the SIR
//
// The AST is stored two fold. All expression and statements are assigned a unique identifier and
// stored in the `statements` and `expression` maps respectively. The indivudual relations between
// the nodes, hence the *tree* strucutre, is encoded indirectly via IDs into the maps (this is way
// children nodes are encoded via `StmtID` and `ExprID`). 
// This is necessary as protobuf lacks proper polymorphism and forward declarations.
//
// @ingroup sir_proto
message AST {
  // List of all statements
  map<int32, Stmt> statements = 1;

  // List of all expressions
  map<int32, Expr> expressions = 2;

  // Root node
  StmtID root = 3;
}

/*===------------------------------------------------------------------------------------------===*\
 *     Stencil
\*===------------------------------------------------------------------------------------------===*/

// @brief Stencil description of the SIR 
//
// A stencil represents the executation of a series of statements on a finite number of input fields
// producing a finite number of output fields, hence a stencilcan have multiple output fields. 
// Hence, a stencil is described by an AST and a list of participating Field(s).
//
// @ingroup sir_proto
message Stencil {
  // Name of the stencil
  string name = 3;

  // Source location of the stencil
  SourceLocation loc = 4;

  // Stencil description AST
  AST ast = 1;

  // Fields referenced by this stencil
  repeated Field fields = 2;

  // Attributes of the stencil
  Attributes attributes = 5;
}

/*===------------------------------------------------------------------------------------------===*\
 *     StencilFunction
\*===------------------------------------------------------------------------------------------===*/

// @brief Stencil function description of the SIR 
//
// Stencil functions are represented, like stencils, by a unique identifier, a list of arguments
// and a list vertical intervals and coressponding AST(s). The latter allows to *specialize* the 
// stencil function for a specific vertical interval enabling straight-forward incorporation of 
// vertical boundary conditions. Next to simple field and scalar arguments, stencil functions can be
// parametrized on Direction `(i, j or k)` and Offset `(i+1) arguments. 
//
// @ingroup sir_proto
message StencilFunction {
  // Name of the stencil function
  string name = 5;

  // Source location of the stencil function
  SourceLocation loc = 4;

  // Stencil body ASTs
  repeated AST asts = 1;

  // Associated intervals of the AST
  repeated Interval intervals = 2;

  // Fields referenced by this stencil
  repeated StencilFunctionArg arguments = 3;

  // Attributes of the stencil function
  Attributes attributes = 6;
}

/*===------------------------------------------------------------------------------------------===*\
 *     StencilFunction
\*===------------------------------------------------------------------------------------------===*/

// @brief Value of a global variable
message GlobalVariableValue {
  // Type and value of the variable
  oneof Value {
    bool boolean_value = 1;
    int32 integer_value = 2;
    double double_value = 3;
    string string_value = 4;
  }

  // Is the value a a compile time constant?
  bool is_constexpr = 5;
}

// @brief Map of global variables
//
// The support of global variables is essential for scientific models to store switches to
// control the flow of the execution, like the order of the horizontal advection, or simulation
// parameters such as the time step of the model. A global variable is identified by a unique
// name and a value which can either be set statically at compile time or dynamically at run
// time.
//
// @ingroup sir_proto
message GlobalVariableMap {
  map<string, GlobalVariableValue> map = 1; // Mape of global variables (name to value)
}

/*===------------------------------------------------------------------------------------------===*\
 *     SIR
\*===------------------------------------------------------------------------------------------===*/

// @brief Protobuf description of the SIR
//
// The Stencil Intermediate Representation (SIR) allows to define multiple high level DSLs in a 
// lightweight manner by reusing most of the complex toolchain i.e the Dawn library.
//
// @ingroup sir_proto
message SIR {
  // Name of the file the SIR was parsed from (can be empty)
  string filename = 4;

  // List of stencils
  repeated Stencil stencils = 1;

  // List of stencil functions
  repeated StencilFunction stencil_functions = 2;

  // Map of global variables
  GlobalVariableMap global_variables = 3;
}
